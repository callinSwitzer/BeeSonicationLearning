---
output: html_document
editor_options: 
  chunk_output_type: console
---

<pre>
## Visualize experiment from hives 7-8
## Bees were given two treatments -- reward first or second
</pre>



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/Users/cswitzer/Dropbox/SonicationBehavior")
```

```{r}
#install packages
ipak <- function(pkg){
     new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
     if(length(new.pkg)) install.packages(new.pkg, dependencies = TRUE)
     sapply(pkg, require, character.only = TRUE)
}

packages <- c("ggplot2", "reshape2", 'lme4', 'sjPlot', "multcomp", 
              "plyr", "effects", "viridis", "GGally", "survminer", 
              "tidyr","gamm4")
ipak(packages)

# set ggplot theme
theme_set(theme_classic() + theme(axis.text=element_text(colour="black")))

# define data and figure directories
dataDir <- "/Users/cswitzer/Dropbox/SonicationBehavior/SonBehData"
figDir <- "/Users/cswitzer/Dropbox/SonicationBehavior/SonBehFigs"


# print system info
print(paste("last run ", Sys.time()))
print(R.version)
```


# Read in data
```{r}
bees <- read.csv(file.path(dataDir, "03_StartStop_cleaned.csv"))
bees$hive = as.factor(bees$hive)
head(bees)

# calculate mean freq rewarded vs. unrewarded for each bee
# to make sure it agrees with what is already in the dataframe
tapply(bees$freq, INDEX = list(bees$beeID, bees$treatment_rewarded), mean)

# number of bees -- should be 96
length(unique(bees$BeeNumCol))

# num observations -- should be 5851
nrow(bees)
```

## Visualize data
```{r}
ggplot(bees, aes(y = freq, x = treatment_rewarded)) +
     geom_boxplot() +  
     stat_smooth(method = "loess", span = 0.75)

bees$trt2 <- mapvalues(bees$treatment, from = c("RewFir", "RewSec"), 
                       to = c("Rewarded 1st 50 Buzzes", "Rewarded 2nd 50 Buzzes"))

ggplot(bees, aes(x = visitNum, y = freq, color = treatment_rewarded)) +
     stat_smooth(method = "loess", span = 1) + 
     xlab("Buzz Number") + 
     ylab("Buzz Frequency(hz)") + 
     facet_wrap(~trt2) + 
     scale_color_viridis(name = "Rewarded Buzzes", 
                         discrete = TRUE, begin = 0.2, end = 0.6)
#ggsave("beeRewards.png", width = 8, height = 5)


# make survival plot
survBees <- t(sapply(unique(bees$beeID), function(x) {
     tmp <- bees[bees$beeID == x, ]
     return(tmp[which.max(tmp$visitNum), ])
}))


lastObs <- as.data.frame(survBees)
lastObs$index <- as.numeric(lastObs$visitNum)


# 1 = censored, 2 = stopped buzzing for 5 min
lastObs$status <- mapvalues(lastObs$index == 100, from = c(TRUE, FALSE), to = c(1, 2))

# create survival object
lastObs$survObj <- with(lastObs, Surv(index, status == 2))
head(lastObs)

lastObs$treatment <- as.factor(unlist(lastObs$treatment))


## Kaplan-Meier estimator. 
km.as.one <- survfit(survObj ~ 1, data = lastObs, conf.type = "log-log")
km.by.trt <- survfit(survObj ~ treatment, data = lastObs, conf.type = "log-log")

par(mfrow = c(1,1))
plot(km.by.trt)

gsv <- ggsurvplot(km.by.trt, CI = FALSE) 

gsv$plot + facet_wrap(~treatment) + 
     theme_bw()   + 
     theme(legend.position = "none")  + 
     scale_color_viridis(discrete = TRUE, begin = 0.3, end = 0.7, option = "magma")  + 
     xlab("Buzz Number") + 
     ylab("Proportion Sonicating") 

#ggsave("beeSonicationPercentage.pdf", width = 8, height = 5)


ggsurv(km.by.trt, CI = FALSE, surv.col = c("#a6cee3", "#1f78b4")) + 
     ylim(c(0, 1)) + 
     xlab("Buzz Number") + 
     ylab("Proportion Sonicating") 

xtabs(~lastObs$treatment + as.character(lastObs$hive))

```


### Visualize data -- averaged by bee

This is not super informative

```{r}
beeAvgs = bees[bees$visitNum == 1, ]
nrow(beeAvgs) # should be 96
head(beeAvgs)


data_long <- gather(beeAvgs[, c("BeeNumCol", "meanFreqRewarded", "meanFreqUnrewarded")], condition, meanFreq, meanFreqRewarded, meanFreqUnrewarded)
head(data_long)


ggplot(data_long, aes(x = condition, y = meanFreq)) + 
  geom_boxplot()

# look at diffs
beeAvgs$buzzDiff = beeAvgs$meanFreqRewarded - beeAvgs$meanFreqUnrewarded
hist(beeAvgs$buzzDiff)
```




# Analysis with start/stop trials

#### GAMM4 shows time series

```{r}

# start with gamm so I can show change by visit number
g01 = gamm4(freq ~ s(visitNum, by = trt2) + IT_mm + hive , random =  ~(1|beeID), data = bees)
par(mfrow = c(2,2))
aab <- plot(g01$gam, all.terms = TRUE, rug = FALSE, shade = TRUE)
summary(g01$gam) # Summary for paper 
summary(g01$mer)
dev.off()

# save gamm plots
pdf(file.path(figDir, "Gamm_startStop_1st50.pdf"), width = 4, height = 3)
par(mai= c(0.9,1,0.3,0.3))
dd = expression(paste('Estimated ', Delta, " frequency (Hz)"))
plot.gam(select = 1, xlab = "Visit number", ylab = dd, g01$gam, all.terms = TRUE, rug = FALSE, shade = TRUE, bty = "l")
mtext("bees rewarded first", side = 2, padj = -3.5)
abline(v=50, lty = 2)
dev.off()


pdf(file.path(figDir, "Gamm_startStop_2nd50.pdf"), width = 4, height = 3)
par(mai= c(0.9,1,0.3,0.3))
dd = expression(paste('Estimated ', Delta, " frequency (Hz)"))
plot.gam(select = 2, xlab = "Visit number", ylab = dd, g01$gam, all.terms = TRUE, rug = FALSE, shade = TRUE, bty = "l")
mtext("bees rewarded second", side = 2, padj = -3.5)
dev.off()

```


### LMER analysis

```{r}

mod1 <- lmer(freq ~ trt2 * treatment_rewarded + IT_mm + hive + (1|beeID), data = bees)
summary(mod1)

plot(mod1)

# diagnostics -- use REML = TRUE
m1 <- update(mod1, .~., REML =TRUE)
summary(m1) # summary for paper
plot(m1)
qqnorm(ranef(m1)$beeID[[1]])
qqline(ranef(m1)$beeID[[1]])

sjp.lmer(m1, type = "re", sort = TRUE) # plot random effects to find any outliers
sjp.lmer(m1, type = 'fe', sort = TRUE, p.kr = FALSE) # plot fixed effects

```

### Bootstrap CI's for figure for paper

```{r bootstrap, cache = TRUE}
# set number of bootstrap replicates for models
nbootSims = 1000

table(bees$hive) # more trials from hive 3

# using hive 7, since it's the one with the most data

# calculate an average IT for prediction
ITmean = mean(tapply(bees$IT_mm, INDEX = bees$beeID, FUN = function(x) x[1] ))

pframe <- data.frame(trt2 = rep(levels(droplevels(bees$trt2)), 2),
                     treatment_rewarded = rep(levels(bees$treatment_rewarded), each = 2),
                     IT_mm = ITmean, 
                     hive = factor(7, levels = levels(bees$hive)),  
                     beeID = 99999)
pframe$freq <- 0
pp <- predict(m1, newdata = pframe, re.form=NA, type = 'response') # re.form sets all random effects to 0



### Calculate CI's (using bootstrap, not accounting for random effects)
bb2 <- bootMer(m1, FUN=function(x) predict(x, pframe, re.form=NA, type = 'response'), nsim = nbootSims)
print(paste("Number of bootstrap samples", nrow(bb2$t)))
bb2_se <-apply(bb2$t,2,function(x) quantile(x, probs = c(0.025, 0.975)))
pframe$blo<-bb2_se[1,]
pframe$bhi<-bb2_se[2,]
pframe$predMean <- pp
pframe
```

### Make frequency plots for paper

```{r figure-making}
# "Mean and bootstrap CI based on fixed-effects uncertainty ONLY"
facLevs = c("Rewarded 1st 50 Buzzes\n (buzz #51-100)", 
               "Rewarded 2nd 50 Buzzes\n (buzz #1-50)", 
               "Rewarded 1st 50 Buzzes\n (buzz #1-50)",
               "Rewarded 2nd 50 Buzzes\n (buzz #50-100)"
               )

pframe$t2 <- factor(facLevs,  levels = facLevs[c(3,1,2,4)])


g00 <- ggplot(pframe, aes(x=t2, color = treatment_rewarded, y=predMean))+
     geom_point()+ 
     labs(y = "Sonication frequency (Hz)", x = "Treatment") + 
    theme(legend.position = c(.74,.8), 
          legend.background = element_rect(fill=alpha('gray90', 0.5)), 
          axis.text.x = element_text(angle = 25, hjust = 0.9)) +
     geom_errorbar(aes(ymin = blo, ymax = bhi), width = 0.1) + 
  scale_color_viridis(discrete = TRUE, name  = "Bees Rewarded?", begin =0.3, end = 0.8) + 
  geom_vline(aes(xintercept = 2.5))
g00
ggsave(plot = g00, filename = file.path(figDir, "StartStopPreds_freq2.pdf"), width =5, height = 3.5)


fac2Levs = c("51-100","1-50", "1-50","51-100")
              

pframe$buzzNums <- factor(fac2Levs,  levels = fac2Levs[c(3,1)])

g001 <- ggplot(pframe, aes(x=buzzNums, color = treatment_rewarded, y=predMean))+
     geom_point()+ 
     labs(y = "Sonication frequency (Hz)", x = "Sonication Number") + 
    theme(legend.position = c(.74,.8), 
          legend.background = element_rect(fill=alpha('gray90', 0.5))) +
     geom_errorbar(aes(ymin = blo, ymax = bhi), width = 0.1) + 
  scale_color_viridis(discrete = TRUE, name  = "Bees Rewarded?", begin =0.3, end = 0.8) +
  facet_wrap(~trt2)
g001
ggsave(plot = g001, filename = file.path(figDir, "StartStopPreds_freq3.pdf"), width =5, height = 3.5)

g0 <- ggplot(pframe, aes(x=trt2, color = treatment_rewarded, y=predMean))+
     geom_point(position = position_dodge(width = 0.4))+ 
     labs(y = "Sonication frequency (Hz)", x = "Treatment") + 
    theme(legend.position = c(.74,.8), 
          legend.background = element_rect(fill=alpha('gray90', 0.5))) +
     geom_errorbar(aes(ymin = blo, ymax = bhi), width = 0.1, position = position_dodge(width = 0.4)) + 
  scale_color_viridis(discrete = TRUE, name  = "Bees Rewarded", begin =0.3, end = 0.8) + 
  geom_vline(aes(xintercept = 1.5))
g0
ggsave(plot = g0, filename = file.path(figDir, "StartStopPreds_freq.pdf"), width =4, height = 3)
```






```{r}
plot(mod1)

preds <- predict(mod1, re.form = NA)

plot(bees2$index, preds, col = as.factor(bees2$trt))

## gam
library(mgcv)

bees3 <- bees2[bees2$index < 50, ]
bees3 <- bees2
gam1 <- gam(bees3$freq ~ s(bees3$index, by = as.factor(bees3$trt)) + bees3$lessThan50 +
                 s(as.factor(bees3$beeNum),bs = "re"))
summary(gam1)


par(mfrow = c(2,2))
plot(gam1, residuals = FALSE, cex = 1)

# get predictions, setting rand. effect to 0
preds  = predict(gam1, exclude="s(as.factor(bees3$beeNum))")


plot(bees3$index, preds)

plot(y = residuals(gam1), bees2$index)

```


# Bootstrap (probably too simple to use for publication)
```{r}
head(beeAvgs)


beeAvgs$difference = beeAvgs$Second50 - beeAvgs$First50

ggplot(beeAvgs, aes(y = difference, x = trt)) + 
     geom_boxplot()


bootFun <- function(o){
     beeSamp <- beeAvgs[sample(1:nrow(beeAvgs), replace = TRUE), ]
     mns <- tapply(beeSamp$difference, INDEX = beeSamp$trt, mean, na.rm = TRUE)
     return(diff(mns))
}
 

bootDiffs <- replicate(n = 100000, bootFun())    

par(mfrow = c(1,1))
hist(bootDiffs)
abline(v = 0)

mean(bootDiffs > 0)
```


# bootstrap different time steps and creat 95% CI for the mean for each group
```{r, eval = FALSE}
head(bees2)


# for each index, make bootstrap 95% CI's
indxFun <- function(idx) {
     beeSmp <- bees2[bees2$index == idx, ]
     beeSmp2 <- beeSmp[sample(1:nrow(beeSmp), replace = TRUE), ]
     mns1 <- tapply(beeSmp2$freq, INDEX = beeSmp2$trt, mean, na.rm = TRUE)
     return(mns1)
}

bootF2 <- function(o) t(sapply(1:100, indxFun))

bootSamps <- replicate(n = 10000, bootF2())

df1 <- as.data.frame(bootSamps)

rewFirDF <- df1[, grep(pattern = "RewFir", colnames(df1))]
rewSecDF <- df1[, grep(pattern = "RewSec", colnames(df1))]

frQuantiles <- t(apply(rewFirDF, MARGIN = 1, FUN = quantile, c(0.025, 0.975)))
seQuantiles <- t(apply(rewSecDF, MARGIN = 1, FUN = quantile, c(0.025, 0.975)))

plot(x = 1:100, y = frQuantiles[, 1], type = 'l', ylim = c(300, 400))
lines(x = 1:100, y = frQuantiles[, 2], type = 'l')

lines(x = 1:100, y = seQuantiles[, 1], type = 'l', col = 'red')
lines(x = 1:100, y = seQuantiles[, 2], type = 'l', col = 'red')

# calculate mean

meanVals <- t(sapply(1:100, function(idx){
     beeSmp <- bees2[bees2$index == idx, ]
     mns1 <- tapply(beeSmp$freq, INDEX = beeSmp$trt, mean, na.rm = TRUE)
     return(mns1)
}))

meanVals

lines(x = 1:100, y = meanVals[,1], lwd = 3)
lines(x = 1:100, y = meanVals[,2], lwd = 3, col = 'red')


plot(x = 1:100, y = meanVals[,2], lwd = 3, col = 'red', type = 'l')
lines(x = 1:100, y = meanVals[,1], lwd = 3)

```


# A different bootstrap analysis -- resampling whole time-series
```{r, eval = FALSE}
beesList <- unique(bees2$beeNum)

# for each index, make bootstrap 95% CI's
indxFun <- function(o) {
     beeListSample <- sample(beesList, replace = TRUE)
     bootDF <- (lapply(beeListSample, function(x) return(bees2[bees2$beeNum == x, ])))
     bootDF1 <- ldply(bootDF, data.frame)
     
     # calculate mean for each timepoint
     meanVals <- t(sapply(X = 1:100, function(idx){
          beeSmp <- bootDF1[bootDF1$index == idx, ]
          mns1 <- tapply(beeSmp$freq, INDEX = beeSmp$trt, mean, na.rm = TRUE)
          return(mns1)
          }))

     return(meanVals)
}

head(indxFun())

bootSamps <- lapply(1:1000, indxFun)

rewFirls <- lapply(bootSamps, function(x) x[,1])
rewSecLs <- lapply(bootSamps, function(x) x[,2])

dfir <- colMeans(do.call("rbind", rewFirls))
dsec <- colMeans(do.call("rbind", rewSecLs))

plot(x = 1:100, y = dfir, type = 'l')
lines(x = 1:100, y = dsec, type = 'l', col = 'red')
lines(x = 1:100, y = dfir, type = 'l')

dfirQuants <- apply(X = do.call("rbind", rewFirls), MARGIN = 2, quantile, c(0.025, 0.975))
dsec <- (do.call("rbind", rewSecLs))


# put survival plot in background

# get data about amount of pollen in different species

```




# amplitude analysis
```{r}
ggplot(bees2, aes(x = index, y = amp, color = trt)) +
     geom_point(alpha = 0.1) + 
     stat_smooth(method = "loess", span = 0.75)

bees2$treatment <- mapvalues(bees2$trt, from = c("RewFir", "RewSec"), to = c("Rewarded_1st_50_Buzzes", "Rewarded_2nd_50_Buzzes"))

ggplot(bees2, aes(x = index, y = amp, color = rewTF)) +
     stat_smooth(method = "loess", span = 1) + 
     xlab("Buzz Number") + 
     ylab("Buzz Amplitude (V)") + 
     facet_wrap(~treatment) + 
     scale_color_viridis(name = "Rewarded Buzzes", 
                         discrete = TRUE, begin = 0.2, end = 0.6)
ggsave("beeRewards_Amplitude.png", width = 8, height = 5)

```

# calculate average for each individual before and after treatment
```{r}
beeAvgs <- as.data.frame(tapply(X = bees2$freq, INDEX = list(bees2$beeNum, bees2$lessThan50), mean))
beetrt <- as.data.frame(sapply(X = unique(bees2$beeNum), FUN = function(x) bees2[bees2$beeNum == x, ][1, "trt"]))

beeAvgs <- cbind(beeAvgs, beetrt)

colnames(beeAvgs) = c("Second50", "First50", "trt")

beeAvgs$beeNum = row.names(beeAvgs)

# convert to long format
library(tidyr)

data_long <- gather(beeAvgs, condition, frequency, First50, Second50)
data_long

dl <- data_long[order(data_long$beeNum), ]

head(dl)


g4 <- ggplot(dl, aes(x = condition, y = frequency, fill = trt)) +
     geom_boxplot() + 
     facet_wrap(~trt) + 
     geom_point(position = position_jitter(width = 0.1))
g4

g5 <- ggplot(dl, aes(x = condition, y = frequency, fill = trt)) +
  stat_summary(fun.data=MinMeanSEMMax, geom="boxplot", colour="red") + 
     facet_wrap(~trt) + 
     geom_point(position = position_jitter(width = 0.1))
g5


```


