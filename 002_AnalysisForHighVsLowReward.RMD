---
output: html_document
editor_options: 
  chunk_output_type: console
---


<pre>

## Callin Switzer
## 17 Nov 2017
## Multilevel model to visualize bees'
## behavior on the artificial pollen system

## Update 30 July 2018 -- investigate proportion of time rewarded

</pre>



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# define data and figure directories
windows = ifelse(grepl(pattern = "wind", ignore.case = TRUE, 
                       x = Sys.info()[1]), TRUE, FALSE)
  
{if(windows){
  rd = "D:/Dropbox/SonicationBehavior"
}
else{
  rd = "/Users/cswitzer/Dropbox/SonicationBehavior"
}}

knitr::opts_knit$set(root.dir =rd )
```


```{r}
#install packages
ipak <- function(pkg){
     new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
     if(length(new.pkg)) install.packages(new.pkg, dependencies = TRUE)
     sapply(pkg, require, character.only = TRUE)
}

packages <- c("tidyverse", "reshape2", 'lme4', 'sjPlot', 
              "multcomp",  "effects")
ipak(packages)

# set ggplot theme
theme_set(theme_classic() + theme(axis.text=element_text(colour="black"), text=element_text(size=16)))


# define data and figure directories
{if(windows){
  # windows
  dataDir <- "D:/Dropbox/SonicationBehavior/SonBehData"
  figDir <- "D:/Dropbox/SonicationBehavior/SonBehFigs"
  }
else{
  # mac
  dataDir <- "/Users/cswitzer/Dropbox/SonicationBehavior/SonBehData"
  figDir <- "/Users/cswitzer/Dropbox/SonicationBehavior/SonBehFigs"
}}

# check if the directory exists
file.info(dataDir)$isdir

print(paste("last run ", Sys.time()))
print(R.version)
```


### Read in data and double check it

```{r}
sl <- read_csv(file.path(dataDir, '01_CombinedTrials_cleaned.csv'))
colnames(sl)


sl <- sl %>%
  # gets rid of the copious warnings
  mutate(timeSinceStart = NA, timeSinceLastBuzz = NA, buzzesSinceReward = NA) %>%
  # make sure all bee colors are lowercase
  mutate(beeCol =  tolower(beeCol)) %>%
  
  # fix orange.5, which should be orange.3
  mutate(hive = ifelse(hive == "5" & beeCol == "orange", "3", hive)) %>%
  # color + hive is an ID var 
  mutate(beeColHive = interaction(beeCol, hive), 
         colNum = paste(beeCol, hive, sep = "_")) %>%
  # remove two trials I messed up
  filter(!(beeCol == "whitepink" & trialNum == 3)) %>%
  filter(!(beeCol == "limepurple" & trialNum == 3)) %>%
  

  # convert hive to factor
  mutate(hive = as.factor(hive),
         trt2  = ifelse(trt == 'full' & trialNum > 1, "full_2", as.character(trt)), 
         trt = relevel(factor(trt), ref = "full")) %>%
  # divide amplitud by 2
  mutate(amp_acc2 = amp_acc / 2) %>%
  mutate(trialNum0 = trialNum - 1)
  


initialFreqAmp <- sl %>%
  dplyr::select(beeColHive, trialNum, freq, amp_acc2) %>%
  filter(trialNum == 1) %>%
  group_by(beeColHive) %>%
  summarize(initialFreq = mean(freq), 
            initialAmp2 = mean(amp_acc2)) %>%
  full_join(sl) %>%
  mutate(ampDiff = amp_acc2 - initialAmp2, 
         freqDiff = freq - initialFreq) %>%
  dplyr::select(beeColHive, trialNum, freqDiff, ampDiff, 
                IT_imputed, rewTF, trt, hive, trt2, 
                freq, amp_acc2, trialNum0, initialFreq, initialAmp2) 


# calculate proportion of rewards by trt
prop.table(xtabs(~ initialFreqAmp$rewTF + initialFreqAmp$trt), margin = 2)
xtabs(~ initialFreqAmp$rewTF + initialFreqAmp$trt)


# number of trials per bee
sl %>% 
  group_by(beeColHive) %>%
  summarize(count = n()) %>%
  print(n = Inf)
hist(xtabs(~as.character(sl$beeColHive)))
max(xtabs(~sl$beeCol))
mean(xtabs(~sl$beeCol))
sd(xtabs(~sl$beeCol))


# number of visits for first trial
xtabs(~sl$beeCol[sl$trialNum == 1])
hist(xtabs(~sl$beeCol[sl$trialNum == 1]))
mean(xtabs(~sl$beeCol[sl$trialNum == 1]))
sd(xtabs(~sl$beeCol[sl$trialNum == 1]))



# number of visits for second trial
xtabs(~sl$beeCol[sl$trialNum == 2])


# number of trials per bee and treatment
xtabs(~sl$beeCol +  sl$trt)
colSums(xtabs(~sl$beeCol +  sl$trt))
# total num
sum(colSums(xtabs(~sl$beeCol +  sl$trt)))

xtabs(~sl$beeCol +  sl$IT_imputed)

# hist(unique(sl$IT_imputed[sl$trt2 == "low"]))
# rug(unique(sl$IT_imputed[sl$trt2 == "low"]))
# 
# hist(unique(sl$IT_imputed[sl$trt2 == "high"]))
# rug(unique(sl$IT_imputed[sl$trt2 == "high"]))

# number of trials per bee and treatment
xtabs(~sl$beeCol +  sl$trialNum)

# tabulate num bees in each trt
tdf <- data.frame(xtabs(~sl$beeCol +  sl$trt))
tdf2 <- acast(tdf, sl.beeCol~sl.trt, value.var="Freq")
tdf3 <- as.data.frame(tdf2 > 0)

trtdf<-table(interaction(tdf3$full, tdf3$high, tdf3$low))
names(trtdf) <- c("FULL ONLY", "FULL-HIGH", "FULL-LOW", "NA")
trtdf

# get number of buzzes in each treatment
colSums(tdf2)

# get the number of bees for each treatment (every bee has "full" treatment)
apply(tdf2, MARGIN = 2, function(x) length(x[x>0]))


head(sl)
dim(sl) # should be 24176 rows

# hive 5 is most common
table(sl$hive, useNA = 'always')



# make sure there are values lower than 220 and higher than 450 
# (the cutoff for buzzes used in the experiment)
hist(sl$freq, breaks = seq(215, 450, by = 10))
nrow(sl[sl$freq < 220 | sl$freq > 450,]) # should have 0 rows


# look at treatments
xtabs(~sl$beeCol+ trt, data = sl )

# find percentage reward by treatment
mean(grepl("[tT]", as.character(sl$rewTF))) # overall mean

# percentage that were rewarded by treatment
tapply((grepl("[tT]", as.character(sl$rewTF))), INDEX= sl$trt, mean)

# std dev for rewards by treatment
s2 = sl %>%
  mutate(beeColHive = interaction(beeCol, hive), 
         reward= grepl(pattern = "t", x = .$rewTF, ignore.case = TRUE)*1) 


s3 = s2 %>%
  group_by(beeColHive, trt2) %>%
  dplyr::summarize(mean_reward = mean(reward)) %>%
  group_by(trt2) %>%
  dplyr::arrange(desc(trt2)) 

s3

# summary for paper
s3 %>%
  dplyr::summarize( mean_ = mean(mean_reward), reward_sd = sd(mean_reward), n = n()) %>%
  mutate(se = reward_sd / sqrt(n))


# total number of trials for each treatment
tapply((grepl("[tT]", as.character(sl$rewTF))), INDEX= sl$trt, length)

# total number of rewards per treatment
tapply((grepl("[tT]", as.character(sl$rewTF))), INDEX= sl$trt, FUN = function(x) sum(x))

# total number of trials that were unrewarded per treatment
tapply((grepl("[tT]", as.character(sl$rewTF))), INDEX= sl$trt, FUN = function(x) sum(!x))


# calculate avg freq & SE

se <- function(x) {
  sd(x) /  sqrt(length(x))
}


s4 = s2 %>%
  group_by(beeColHive, trt2) %>%
  dplyr::summarize(mean_freq = mean(freq), 
                   sd_freq = sd(freq)) %>%
  group_by(trt2) %>%
  dplyr::arrange(desc(trt2)) %>%
  filter(trt2 != "full") %>%
  ungroup() %>%
  mutate(trt3 = plyr::mapvalues(.$trt2, from = c("full_2", "high", "low"), 
                        to = c("Full range\n(220 - 450 Hz)", 
                               "High range\n(340 - 390 Hz)", 
                               "Low range\n(220 - 330 Hz)")))




# plot bee size in the groups
sl_sum <- sl %>%
  dplyr::select(beeColHive, trt2, IT_imputed) %>%
  distinct(beeColHive, trt2, .keep_all = TRUE) 

sl_sum %>% print(n = 50)

sl_sum %>%
  group_by(trt2) %>%
  summarize(counts = n())

sl %>% nrow

sl %>% group_by(beeColHive) %>%
  summarize(n()) %>%
  nrow()

print(unique(sl$beeColHive))

print(unique(sl$beeCol))



sl %>% group_by(trt2) %>%
  summarize(count= n())

sl_sum %>% group_by(trt2) %>%
  summarize(count= n())

s2 <- sl_sum  %>%
  filter(trt2 != "full")

s2 <- s2 %>%
  mutate(trt3 = plyr::mapvalues(.$trt2, from = c("full_2", "high", "low"), 
                        to = c("Full range\n(220 - 450 Hz)", 
                               "High range\n(340 - 390 Hz)", 
                               "Low range\n(220 - 330 Hz)")))

s44 <- full_join(s2, s4)

s44

set.seed(123)
ggplot(s44, aes(x = trt3,  y= IT_imputed)) + 
  geom_violin(width = 0.5, fill = "grey90", color = NA, bw = 0.2, trim = TRUE) + 
  #geom_boxplot(width = 0.5, outlier.alpha =   0) + 
  geom_point(position = position_jitter(height = 0, width = 0.05), 
             stroke= 0, size = 2.5, color = 'grey40') + 
  labs(x = "Frequency range for reward", y = "Intertegular span (mm)") 
  
ggsave(file.path(figDir, "beeSize_exp1.png"), width = 6, height = 4, units = "in", dpi = 500)
ggsave(file.path(figDir, "beeSize_exp1.svg"), width = 6, height = 4, units = "in")


# plot freq vs. amp
sl <- sl %>%
  mutate(`IT interval (mm)` = cut_interval(IT_imputed, n = 3))

ggplot(sl[sl$trt2 == "full", ], aes(x = freq, y = amp_acc2)) + 
  geom_point(position = position_jitter(height = 0, width = 2), 
             alpha = 0.3, stroke = 0, size = 1.5) + 
  stat_smooth(method = 'loess', span = 1, color = 'grey40', se = FALSE, 
              lwd = 2) + 
  facet_wrap(~`IT interval (mm)`, labeller = "label_both") + 
  theme(strip.background = element_blank(), 
        strip.text = element_text(size = 13)) + 
  theme(legend.position = "none", 
        plot.margin = unit(c(1,1,1,1)/2, "cm")) + 
  labs(x = "Sonication Frequency (Hz)", y = expression ("Sonication amplitude   " (m~s^{-2})))


ggsave(file.path(figDir, "freq_amp.png"), width = 8, height = 4, units = "in", dpi = 500)
ggsave(file.path(figDir, "freq_amp.svg"), width = 8, height = 4, units = "in")
```


### MODELING


```{r}

# summary for paper
# fit a varying slope and intercept for colNum (bee ID), and allow the slope of the trialNum
# variable to vary by colNum (beeID)
# basically the same model
sl$trialNum

# treatment (rewarded at high, low, or full range of frequencies), IT span, colony, trial number, and the interaction of treatment and IT span
m2 = lmer(freq ~ trt + IT_imputed + hive + trialNum + trt:IT_imputed + (1+trialNum|beeColHive), data = sl, REML = FALSE)
summary(m2)

# this model estimates a global intercept
# random effect intercept for colNum (beeID)
# a single global estimate for trialNum
# the effect of trialNum within each level of colNum
# the correlation between intercept of trialNum across levels of colNum


vif.mer <- function (fit) {
    ## adapted from rms::vif

    v <- vcov(fit)
    nam <- names(fixef(fit))

    ## exclude intercepts
    ns <- sum(1 * (nam == "Intercept" | nam == "(Intercept)"))
    if (ns > 0) {
        v <- v[-(1:ns), -(1:ns), drop = FALSE]
        nam <- nam[-(1:ns)]
    }

    d <- diag(v)^0.5
    v <- diag(solve(v/(d %o% d)))
    names(v) <- nam
    v
}

vif.mer(m2) # fine


m3 = update(m2, .~. - hive)
BIC(m2, m3) # m3 is better (without hive)
anova(m2, m3) # Note: disagrees with BIC
summary(m3)

m4 <- update(m3, .~. - IT_imputed:trt)
BIC(m3, m4) # m4 better
summary(m4)


m5 <- update(m4, .~. - IT_imputed)
anova(m4, m5) # keep IT, based on BIC


m5 <- update(m4, .~. - trt)
anova(m4, m5) # keep trt


# refit best model with REML = TRUE
m3 <- update(m4, .~., REML = TRUE)
summary(m3) # summary for paper -- leave trial number in, to account for random effect
plot(m3)
qqnorm(ranef(m3)$beeColHive[[1]])
qqline(ranef(m3)$beeColHive[[1]])

plot_model(m3) 
# plot random effects to find any outliers
plot_model(m3, type = "re")

# post-hoc tests -- pvals for paper
summary(glht(m3, linfct = mcp(trt = "Tukey")), test = adjusted("none"))

## bonf adjusted pvals
summary(glht(m3, linfct = mcp(trt = "Tukey")), test = adjusted("bonf"))
```


### Generate CI's
```{r bootstrap, cache = TRUE}

# set number of bootstrap samples
# refref: change to 10K before knitting
nbootSims = 1000

ITmean = mean(tapply(sl$IT_imputed, INDEX = sl$beeCol, FUN = function(x) x[1] ))
print(ITmean)

# don't need hive, because that's not in the model we chose (above)
pframe <- data.frame(expand.grid(trt = levels(sl$trt), 
                                 IT_imputed = seq(min(s2$IT_imputed), max(s2$IT_imputed), length.out = 50),  
                                 beeColHive  = 99999, 
                                 trialNum = 2))
pframe$freq <- 0
pp <- predict(m3, newdata = pframe, re.form=NA, type = 'response') # re.form sets all random effects to 0


### Calculate CI's (using bootstrap, not accounting for random effects)
bb2 <- bootMer(m3, FUN=function(x) predict(x, pframe, re.form=NA, type = 'response'), nsim = nbootSims)
print(paste("Number of bootstrap samples", nrow(bb2$t)))
bb2_se <-apply(bb2$t,2,function(x) quantile(x, probs = c(0.025, 0.975)))
pframe$blo<-bb2_se[1,]
pframe$bhi<-bb2_se[2,]
pframe$predMean <- pp
pframe <- pframe[, c('trt',"IT_imputed", "blo", "bhi", "predMean")]
pframe
```

### Make plots for paper

```{r}
#plot 95% confidence intervals
# "Mean and bootstrap CI based on fixed-effects uncertainty ONLY"
# rename labels for plot
pframe$trt3 = plyr::mapvalues(pframe$trt, from = c("full", "high", "low"), 
                        to = c("Full range\n(220 - 450 Hz)", 
                               "High range\n(340 - 390 Hz)",
                               "Low range\n(220 - 330 Hz)"))

 

s44 <- full_join(s2, s4)

s2

s44 %>% print(n = Inf)


set.seed(1234)
g0 <- ggplot(pframe, aes(x=IT_imputed, y=predMean, color = trt3, fill = trt3))+
        geom_line()+
        facet_wrap(~trt3) + 
        geom_rug(data = s44, aes(x = IT_imputed, color = trt3, y = s44$mean_freq), 
                 inherit.aes = FALSE, sides = "b", 
                 position = position_jitter(height = 0, width = 0.03)) + 
        labs(y = "Sonication frequency (Hz)", x = "Intertegular Span (mm)") + 
        geom_ribbon(aes(ymin = blo, ymax = bhi), alpha = 0.3, color = NA)+
        # geom_point(data = s44, aes(y= mean_freq)) +
        # geom_errorbar(data = s44, aes(x = IT_imputed, ymin = mean_freq - sd_freq,
        #                               ymax = mean_freq + sd_freq, color = trt3),
        #               inherit.aes = FALSE, width = 0.1) +
        theme(plot.background = element_rect(fill = "transparent",colour = NA), 
            panel.background = element_rect(fill = "transparent",colour = NA), 
            legend.position ="none", 
            strip.background = element_blank(), 
            panel.spacing.x = unit(1, "lines"), 
           plot.margin = margin(c(0,0.51, 0.2, 0.2), unit = "cm")) +
        #scale_x_continuous(breaks = seq(3.4, 4.8, by = 0.5)) +
        scale_color_viridis_d(name = "Frequency range\nfor reward", end = 0.7, option = "inferno") + 
        scale_fill_viridis_d(name = "Frequency range\nfor reward", end =0.7, option = 'inferno')
g0

ggsave(plot = g0, filename = file.path(figDir, "SonicationFreqPredsAndCI_unadjusted.png"), unit = "in", dpi = 500,
       width = 5, height = 4)
ggsave(plot = g0, filename = file.path(figDir, "SonicationFreqPredsAndCI_unadjusted.svg"), width = 5, height = 4)

```



## visualization of frequency over time

```{r}
sl <- read_csv(file.path(dataDir, '01_CombinedTrials_cleaned.csv'))
colnames(sl)


sl <- sl %>%
  # gets rid of the copious warnings
  mutate(timeSinceStart = NA, timeSinceLastBuzz = NA, buzzesSinceReward = NA) %>%
  mutate(beeColHive = interaction(beeCol, hive)) %>%
  # remove two trials I messed up
  filter(!(beeCol == "whitepink" & trialNum == 3)) %>%
  filter(!(beeCol == "limepurple" & trialNum == 3)) %>%
  mutate(t5 = recode(.$trt, "full" = "Full range\n(220 - 450 Hz)", 
                       "high" = "High range\n(340 - 390 Hz)\nsecond trial", 
                       "low" = "Low range\n(220 - 330 Hz)\nsecond trial")) %>%
  mutate(t6 = t5, 
         t6 = ifelse(.$trt == 'full' & .$trialNum == 1, 
                     "Full range \n(220 - 450 Hz)\nfirst trial", t5), 
         t6 = ifelse(.$trt == 'full' & .$trialNum > 1, 
                     "Full range \n(220 - 450 Hz)\nsecond trial", t6)
         )



st <- sl %>%
  filter(trialNum <= 10 & trialNum > 1) 


fta <- sl %>% 
  filter(trialNum == 1) %>% 
  dplyr::group_by(beeColHive) %>%
  dplyr::summarise(initialFreq = mean(freq)) %>%
  full_join(sl) %>%
  mutate(freqDiff = freq- initialFreq) %>%
  filter(beeColHive %in% .$beeColHive[.$trialNum > 1]) %>%
  dplyr::arrange(trt) 

fta[fta$beeColHive == "limepurple.5", ]

cc <- fta %>%
  filter(trialNum > 1) %>%
  group_by(beeColHive) %>%
  summarize(meanFreq = mean(freq))
cc %>% print(n = Inf)


bb <- fta %>%
  dplyr::select(beeColHive, trt, trialNum, initialFreq) %>%
  dplyr::filter(trialNum == 2 | trialNum == 3) %>%
  group_by(beeColHive) %>% 
  slice(1:1) %>%
  full_join(cc) %>%
  mutate(freqDiff = initialFreq - meanFreq) %>%
  dplyr::arrange(trt, desc(freqDiff))

bb

fta <- fta %>%
  mutate(beeColHive = factor(beeColHive, levels = bb$beeColHive)) %>% 
  mutate(t5 = recode(.$trt, "full" = "Full range\n(220 - 450 Hz)", 
                       "high" = "High range\n(340 - 390 Hz)", 
                       "low" = "Low range\n(220 - 330 Hz)")) %>%
  filter(trialNum <= 10)



s44 = fta %>%
  group_by(trialNum, beeColHive, t5) %>%
  dplyr::summarise(meanFreq2 = mean(freq))
s44

# plot to show trials

ggplot(fta, aes(x = trialNum, y = freq, color = t5)) + 
  geom_ribbon(data = fta[fta$trialNum > 1,], 
              aes(x = rep(seq(1.5, 12, 3),  
                          length.out = nrow(fta[fta$trialNum > 1,])), 
                  ymin = lowFrq, ymax = highFrq), alpha = 0.2, color = NA) + 
  geom_point(position = position_jitter(width = 0, height = 10), 
             alpha= 0.2, stroke = 0, aes( shape = t5 )) + 
  
  facet_wrap(~beeColHive, ncol = 8) +
    
  geom_line(data = s44, aes(x = trialNum, y = meanFreq2), color = 'black', lwd = 0.8, show.legend = FALSE) + 
  geom_line(data = s44, aes(x = trialNum, y = meanFreq2, color = t5), lwd = 0.8, show.legend = FALSE) + 
  
  geom_point(data = s44, aes(x = trialNum, y = meanFreq2), 
             color = 'black', pch = 18, show.legend = FALSE) + 

  
  geom_ribbon(data = fta[fta$trialNum > 1,], 
              aes(x = rep(seq(0.5, 1.5, 1),  
                          length.out = nrow(fta[fta$trialNum > 1,])), 
                  ymin = 220, ymax = 450), alpha = 0.2, color = NA) + 
  geom_hline(aes(yintercept = initialFreq)) + 
  # stat_smooth(data = fta[fta$trialNum > 1,], 
  #             method = 'loess', se = FALSE, 
  #             size =1.5, color = 'black', span = 0.6) + 
  # stat_smooth(data = fta[fta$trialNum > 1,], 
  #             method = 'loess', 
  #             se = FALSE, size =1, span = 0.6) + 
  scale_x_continuous(breaks = seq(0, 10, 2)) + 
  scale_color_viridis_d(name = "",
                        option = "magma", begin = 0.3,
                        end = 0.80, 
                        guide = guide_legend(override.aes = list(alpha = 1, size = 4))) + 
  theme_classic() + 
  theme(strip.background = element_blank(), 
        strip.text = element_blank(), 
        panel.border = element_rect(colour = "grey40", 
                                    fill=NA, size=0.5), 
        legend.position = 'top') + 
  scale_shape_manual(name = "", values = c(16,17,15)) + 
   
  labs(y = "Frequency (Hz)", x = "Trial Number")

ggsave(filename = file.path(figDir,"freqLearningCurve.png"),
       dpi = 500,  width = 6.5*1.5, height = 4*1.5, units = "in")


options(digits.secs=6)
# plot buzzes for first trial
ftrl <- sl %>%
  filter(trialNum  <= 2 ) %>%
  mutate(dateTime_fmt= as.POSIXct(strptime(x = .$datetime_str, 
                                           format = "%Y-%m-%d  %H:%M:%OS" ))) %>%
  arrange(dateTime_fmt) %>%
  group_by(beeColHive) %>%
  mutate(index = row_number())
  
dd = sl %>%
  filter(trialNum == 2 | trialNum == 3) %>%
  mutate(trialNum = 99) %>%
  ungroup() %>%
  group_by(beeColHive, trt, trialNum) %>%
  summarise(meanTT = n()) %>%
  arrange(trt, meanTT)
dd

dd %>% print(n = Inf)

ee = sl %>%
  filter(trialNum == 1) %>%
  ungroup() %>%
  group_by(beeColHive, trt, trialNum) %>%
  summarise(meanTT = n()) %>%
  rbind(dd) %>%
  arrange(beeColHive, desc(trialNum)) %>%
  group_by(beeColHive) %>%
  filter(row_number(beeColHive) == 1) %>%
  arrange(trt, meanTT)
  
ee %>% print(n = Inf)



unique(dd$beeColHive)
unique(ftrl$beeColHive)

ftrl = ftrl %>%
  ungroup() %>%
  mutate(beeColHive = factor(.$beeColHive, levels = ee$beeColHive)) %>%
  filter(beeColHive %in% ee$beeColHive[ee$meanTT > 20]) 

ggplot(ftrl, aes(x = index, y = freq, color = t6)) + 
  
  geom_point(alpha = 0.4, stroke = 0, aes(shape = t6)) + 
  facet_wrap(~beeColHive, ncol = 8 ) + 
  stat_smooth(aes(group = t6), method = 'loess', color = "black", se = FALSE, span = 0.7, lwd = 0.4) + 
  scale_color_viridis_d(name = "",
                        option = "magma", begin = 0.3,
                        end = 0.80, 
                        guide = guide_legend(override.aes = list(alpha = 1, size = 4))) + 
  scale_shape_manual(name = "", values = c(16,17,15, 18)) + 
  theme_classic() + 
  theme(strip.background = element_blank(), 
        strip.text = element_blank(), 
        panel.border = element_rect(colour = "grey40", 
                                    fill=NA, size=0.5), 
        legend.position = 'top')  + 
  scale_x_continuous(breaks = seq(0, 400, 200), limits = c(0, 400)) + 
  labs(x = "Sonication Number", y =  "Frequency (Hz)") + 
  geom_ribbon(aes(ymin = lowFrq, ymax = highFrq), alpha = 0.2, color = NA)
  
  
ggsave(filename = file.path(figDir,"FreqChangeFirstAndSecTrial.png"),
       dpi = 500,  width = 6.5*1.5, height = 4*1.5, units = "in")



ggplot(ftrl[ftrl$trialNum == 1,], aes(x = index, y = freq, color = t6)) + 
  
  geom_point(alpha = 0.4, stroke = 0, aes(shape = t6)) + 
  facet_wrap(~beeColHive, ncol = 8 ) + 
  stat_smooth(aes(group = t6), method = 'loess', color = "black", se = FALSE,span =0.7, lwd = 0.4) + 
  scale_color_viridis_d(name = "",
                        option = "magma", begin = 0.3,
                        end = 0.80, 
                        guide = guide_legend(override.aes = list(alpha = 1, size = 4))) + 
  scale_shape_manual(name = "", values = c(16,17,15, 18)) + 
  theme_classic() + 
  theme(strip.background = element_blank(), 
        strip.text = element_blank(), 
        panel.border = element_rect(colour = "grey40", 
                                    fill=NA, size=0.5), 
        legend.position = 'top')  + 
  scale_x_continuous(breaks = seq(0, 50, 20), limits = c(0, 50)) + 
  labs(x = "Sonication Number", y =  "Frequency (Hz)") 
  
  
ggsave(filename = file.path(figDir,"FreqChangeFirstTrial.png"),
       dpi = 500,  width = 6.5*1.5, height = 4*1.5, units = "in")


```



### look at amplitude change over time
```{r}

sl <- sl %>%
  # gets rid of the copious warnings
  mutate(timeSinceStart = NA, timeSinceLastBuzz = NA, buzzesSinceReward = NA) %>%
  mutate(beeColHive = interaction(beeCol, hive)) %>%
  # remove two trials I messed up
  filter(!(beeCol == "whitepink" & trialNum == 3)) %>%
  filter(!(beeCol == "limepurple" & trialNum == 3)) %>%
  mutate(amp_acc2 = amp_acc / 2)




fta <- sl %>% 
  filter(trialNum == 1) %>% 
  dplyr::group_by(beeColHive) %>%
  dplyr::summarise(initialAmp = mean(amp_acc2)) %>%
  full_join(sl) %>%
  mutate(ampDiff = amp_acc2- initialAmp) %>%
  filter(beeColHive %in% .$beeColHive[.$trialNum > 1]) %>%
  dplyr::arrange(trt) 

fta[fta$beeColHive == "limepurple.5", ]

cc <- fta %>%
  filter(trialNum > 1) %>%
  group_by(beeColHive) %>%
  summarize(meanAmp = mean(amp_acc2))
cc %>% print(n = Inf)


# use bb from above, to maintain order
# bb <- fta %>%
#   dplyr::select(beeColHive, trt, trialNum, initialAmp) %>%
#   dplyr::filter(trialNum == 2 | trialNum == 3) %>%
#   group_by(beeColHive) %>% 
#   slice(1:1) %>%
#   full_join(cc) %>%
#   mutate(ampDiff = initialAmp - meanAmp) %>%
#   dplyr::arrange(trt, desc(ampDiff))
# 
# bb

fta <- fta %>%
  mutate(beeColHive = factor(beeColHive, levels = bb$beeColHive), 
       t5 = plyr::mapvalues(.$trt, from = c("full", "high", "low"), 
                        to = c("Full range\n(220 - 450 Hz)", 
                               "High range\n(340 - 390 Hz)", "Low range\n(220 - 330 Hz)"))) %>%
  filter(trialNum <= 10)



s44 = fta %>%
  group_by(trialNum, beeColHive, t5) %>%
  dplyr::summarise(meanamp2 = mean(amp_acc2))
s44

# plot to show trials

ggplot(fta, aes(x = trialNum, y = amp_acc2, color = t5)) + 
  
  geom_point(position = position_jitter(width = 0, height = 0 ), 
             alpha= 0.2, stroke = 0, aes( shape = t5 )) + 
  
  facet_wrap(~beeColHive, ncol = 8) +
    
  geom_line(data = s44, aes(x = trialNum, y = meanamp2), color = 'black', lwd = 0.8, show.legend = FALSE) + 
  geom_line(data = s44, aes(x = trialNum, y = meanamp2, color = t5), lwd = 0.8, show.legend = FALSE) + 
  
  geom_point(data = s44, aes(x = trialNum, y = meanamp2), 
             color = 'black', pch = 18, show.legend = FALSE) + 

  geom_hline(aes(yintercept = initialAmp)) + 
  # stat_smooth(data = fta[fta$trialNum > 1,], 
  #             method = 'loess', se = FALSE, 
  #             size =1.5, color = 'black', span = 0.6) + 
  # stat_smooth(data = fta[fta$trialNum > 1,], 
  #             method = 'loess', 
  #             se = FALSE, size =1, span = 0.6) + 
  scale_x_continuous(breaks = seq(0, 10, 2)) + 
  scale_color_viridis_d(name = "",
                        option = "magma", begin = 0.3,
                        end = 0.80, 
                        guide = guide_legend(override.aes = list(alpha = 1, size = 4))) + 
  theme_classic() + 
  theme(strip.background = element_blank(), 
        strip.text = element_blank(), 
        panel.border = element_rect(colour = "grey40", 
                                    fill=NA, size=0.5), 
        legend.position = 'top') + 
  scale_shape_manual(name = "", values = c(16,17,15)) + 
   
  labs( y = expression ("Sonication amplitude "(m~s^{-2})), x = "Trial Number")

ggsave(filename = file.path(figDir,"AmplChangeOverTime.png"),
       dpi = 200,  width = 6.5*1.5, height = 4*1.5, units = "in")

```



### ____ END OF ANALYSIS FOR PAPER ____ ### 






















### Analysis for amplitude

```{r ampAnalysis}
sl <- read_csv(file.path(dataDir, '01_CombinedTrials_cleaned.csv'))
colnames(sl)

sl <- sl %>%
  # gets rid of the copious warnings
  mutate(timeSinceStart = NA, timeSinceLastBuzz = NA, buzzesSinceReward = NA) %>%
  # make sure all bee colors are lowercase
  mutate(beeCol =  tolower(beeCol)) %>%
  
  # fix orange.5, which should be orange.3
  mutate(hive = ifelse(hive == "5" & beeCol == "orange", "3", hive)) %>%
  # color + hive is an ID var 
  mutate(beeColHive = interaction(beeCol, hive), 
         colNum = paste(beeCol, hive, sep = "_")) %>%
  # remove two trials I messed up
  filter(!(beeCol == "whitepink" & trialNum == 3)) %>%
  filter(!(beeCol == "limepurple" & trialNum == 3)) %>%
  

  # convert hive to factor
  mutate(hive = as.factor(hive),
         trt2  = ifelse(trt == 'full' & trialNum > 1, 
                        "full_2", as.character(trt)), 
         trt = relevel(factor(trt), ref = "full")) %>%
  # divide amplitud by 2
  mutate(amp_acc2 = amp_acc / 2) %>%
  mutate(trialNum0 = trialNum - 1)



# interaction model
nrow(sl)

# note log-transformation to make model fit assumptions better
maa0 = lmer(log(amp_acc2) ~ trt* IT_imputed + hive + trialNum  + (1+trialNum|beeColHive), data = sl, REML = FALSE)

# main effect model
maa1 = lmer(log(amp_acc2) ~ trt+ IT_imputed + hive + trialNum  +(1+trialNum|beeColHive), data = sl, REML = FALSE)
BIC(maa0, maa1) # use no interaction (keep maa1)
anova(maa0, maa1) # note that this agrees with likelihood ratio test


maa2 = update(maa1, .~. - trt)
BIC(maa1, maa2) # keep treatment (maa1)
anova(maa1, maa2) # agrees with LRT; p-val for paper, if needed

maa3 <- update(maa1, .~. - hive)
BIC(maa1, maa3) # remove hive (maa3)
anova(maa1, maa3) # disagrees with LRT
summary(maa3)


m13 <- update(maa3, .~. - IT_imputed)
anova(maa3, m13) # remove IT, according to BIC


# refit with REML = TRUE for paper
m13 <- update(m13, .~., REML = TRUE)
summary(m13)



# diagnostics
plot(m13)
qqnorm(ranef(m13)$beeColHive[[1]])
qqline(ranef(m13)$beeColHive[[1]])


plot_model(m13, type = "re") # plot random effects to find any outliers
plot_model(m13) # plot fixed effects


# post-hoc tests -- pvals for paper
summary(glht(m13, linfct = mcp(trt = "Tukey")), test = adjusted("none"))


# post-hoc tests with bonf adjustment
summary(glht(m13, linfct = mcp(trt = "Tukey")), test = adjusted("bonf"))
```


### Generate CI's for amplitude

```{r bootstrapAmp, cache = TRUE}
# set number of bootstrap samples
nbootSims2 = 10

sl$trt

# don't need to include hive, but will set trialNum to 2
pframe <- data.frame(trt = levels((sl$trt)), 
                     IT_imputed = ITmean,  colNum = 99999, trialNum = 2)
pframe$amp_acc <- 0
# exponentiate to get back to original scale
pp <- exp(predict(m13, newdata = pframe, re.form=NA, type = 'response')) # re.form sets all random effects to 0


### Calculate CI's (using bootstrap, not accounting for random effects)
bb2 <- bootMer(m13, FUN=function(x) predict(x, pframe, re.form=NA, type = 'response'), nsim = nbootSims2)
print(paste("Number of bootstrap samples", nrow(bb2$t)))
bb2_se <-apply(bb2$t,2,function(x) quantile(x, probs = c(0.025, 0.975)))

#exponentiate to get back to orignal scale
pframe$blo<-exp(bb2_se[1,])
pframe$bhi<-exp(bb2_se[2,])
pframe$predMean <- pp
pframe <- pframe[, c('trt', "blo", "bhi", "predMean")]
pframe
```


### Make plots for amplitude for paper

```{r amplitudePlots}
#plot 95% confidence intervals
# "Mean and bootstrap CI based on fixed-effects uncertainty ONLY"
pframe$trt3 = plyr::mapvalues(pframe$trt, from = c("full", "high", "low"), 
                        to = c("Full range\n(220 - 450 Hz)", "High range\n(340 - 390 Hz)", "Low range\n(220 - 330 Hz)"))

pframe
ga0 <- ggplot(pframe, aes(x=trt3, y=predMean))+
     geom_point()+ 
     labs( y = expression ("Sonication amplitude "(m~s^{-2})), x = "Frequency range for reward") + 
     geom_errorbar(aes(ymin = blo, ymax = bhi), width = 0.1)+
     theme(axis.text.x = element_text(angle = 45, hjust = 1), 
           legend.position = 'none') +
     theme_classic() + 
  annotate(geom="text", x=c(1,2,3), y=c(0, 0, 0) + 58/2, label=c("a", "b", "a"),
                color="black") 
ga0
ggsave(plot = ga0, filename = file.path(figDir, "SonicationAmpPredsAndCI_unadjusted.svg"), width = 5, height = 4)


# make plot using bonferroni adjustments

ga0 <- ggplot(pframe, aes(x=trt, y=predMean))+
     geom_point()+ 
     labs( y = expression ("Sonication amplitude "(m~s^{-2})), x = "Frequency range for reward") + 
     geom_errorbar(aes(ymin = blo, ymax = bhi), width = 0.1)+
     theme(axis.text.x = element_text(angle = 45, hjust = 1), 
           legend.position = 'none') +
     theme_classic() + 
  annotate(geom="text", x=c(1,2,3), y=c(0, 0, 0) + 58/2, label=c("a", "b", "a"),
                color="black") 
ga0
ggsave(plot = ga0, filename = file.path(figDir, "SonicationAmpPredsAndCI_BonfAdjusted.svg"), width = 5, height = 4)

```


# Visualize aggregated data for amplitude

```{r}

aggdata <- aggregate(sl$amp_acc, by=list(colNum = sl$colNum,trialNum =sl$trialNum, trt = sl$trt), FUN=mean, na.rm=TRUE)
colnames(aggdata)[colnames(aggdata) == "x"] = "amp"

aggdata_sd <- aggregate(sl$amp_acc, by=list(colNum = sl$colNum,trialNum =sl$trialNum, trt = sl$trt), FUN=sd, na.rm=TRUE)
colnames(aggdata_sd)[colnames(aggdata_sd) == "x"] = "amp_sd"

aggdata = merge(aggdata, aggdata_sd)
aggdata = aggdata[order(aggdata$colNum, aggdata$trialNum, decreasing = FALSE), ]
agg_sm = aggdata[aggdata$trialNum <= 2, ]
rownames(agg_sm) = 1:nrow(agg_sm)
agg_sm



agg_sm[duplicated(data.frame(agg_sm$colNum, agg_sm$trialNum)), ]

ggplot(agg_sm, aes(x = trt, y = amp, fill = trialNum > 1)) +
  geom_boxplot(alpha = 0.2) + 
  geom_point(aes(color = trialNum>1)) + 
  geom_line(aes(group = colNum))


diffdf <- sapply(unique(agg_sm$colNum), FUN = function(x){
  tmp = agg_sm[agg_sm$colNum == x, ]
  if(nrow(tmp) <= 1)
    diff = NA
  else
    diff = tmp$amp[tmp$trialNum == 2] - tmp$amp[tmp$trialNum == 1]
  return(diff)
})

trtDF = sapply(unique(agg_sm$colNum), FUN = function(x){
  tmp = agg_sm[agg_sm$colNum == x, ]
  ttrs = paste(tmp$trt[tmp$trialNum == 1], tmp$trt[tmp$trialNum == 2], sep = "_")
  return(ttrs)
})

buzzdiffs = data.frame(trtDF, diffdf)

ggplot(buzzdiffs, aes(x = trtDF, y= diffdf)) + 
  geom_boxplot() + 
  geom_point()+ 
  labs(y = "amplitude difference m/s/s")

         
agg2 = aggregate(sl$amp_acc, by=list(colNum = sl$colNum, fullTrt = sl$trt == "full", trt = sl$trt), FUN=mean, na.rm=TRUE)
colnames(agg2)[colnames(agg2) == "x"] = "amp"
agg2$trt = as.character(agg2$trt)

diffdf <- t(as.data.frame(t(sapply(unique(agg2$colNum), FUN = function(x){
  tmp = agg2[agg2$colNum == x, ]
  if(nrow(tmp) <= 1)
    return(NA)
  if (length(unique(tmp$trt)) > 2){
    tmp = tmp[tmp$trt != "full_2", ]
  }
  diff =  tmp$amp[!tmp$fullTrt] - tmp$amp[tmp$fullTrt]
  return(diff)

}))))

length(diffdf)

trtDF = sapply(unique(agg2$colNum), FUN = function(x){
  tmp = agg2[agg2$colNum == x, ]
  if (length(unique(tmp$trt)) > 2){
    tmp = tmp[tmp$trt != "full_2", ]
  }
  ttrs = paste(tmp$trt[tmp$fullTrt], tmp$trt[!tmp$fullTrt], sep = "_")
  return(ttrs)
})

length(trtDF)

buzzdiffs = data.frame(trtDF, diffdf)
tapply(buzzdiffs$diffdf, INDEX = buzzdiffs$trtDF, mean)

ggplot(droplevels(buzzdiffs[buzzdiffs$trtDF != "full_", ]), aes(x = trtDF, y= as.numeric(diffdf))) + 
  geom_boxplot() + 
  geom_point()+ 
  labs(y = "amplitude difference m/s/s")
```


## Plot amplitude vs. frequency for initial trial, accounting for size

```{r}
ggplot(sl[sl$trialNum == 1, ], aes(x = freq, y = amp_acc2)) + 
  geom_point(position = position_jitter(width = 1), alpha = 0.2) + 
  theme_classic() + 
  stat_smooth(aes(group = trt), method = "loess", se = TRUE, color = "grey40") + 
  labs( y = expression ("Sonication amplitude "(m~s^{-2})), x = "Sonication Frequency (Hz)")

ggsave(filename = file.path(figDir, "FreqVAmp_t1.png"), width = 6, heigh = 4, dpi = 500, unit = "in")

ggplot(sl[sl$trialNum == 1, ], aes(x = freq, y = amp_acc2)) + 
  geom_point(position = position_jitter(width = 1), alpha = 0.2) + 
  theme_classic() + 
  facet_wrap(~beeColHive) + 
  stat_smooth(aes(group = trt), method = "loess", se = TRUE, color = "grey40") + 
  labs( y = expression ("Sonication amplitude "(m~s^{-2})), x = "Sonication Frequency (Hz)")

ggsave(filename = file.path(figDir, "FreqVAmp_t1_facet.png"), width = 12, heigh = 12, dpi = 500, unit = "in")


ggplot(sl, aes(x = freq, y = amp_acc2, color = trt)) + 
  geom_point(position = position_jitter(width = 1), alpha = 0.01, stroke = 0) + 
  theme_classic() + 
  facet_wrap(~beeColHive) + 
  stat_smooth(aes(color = trt, fill = trt, group = trt), method = "loess", se = FALSE) + 
  labs( y = expression ("Sonication amplitude "(m~s^{-2})), x = "Sonication Frequency (Hz)")

ggsave(filename = file.path(figDir, "FreqVAmp_t1_facet_trt.png"), width = 12, heigh = 12, dpi = 500, unit = "in")





mm1 <- lmer(log(amp_acc2) ~ I(scale(freq)) + I(scale(freq)^2) + I(scale(freq)^3) +
              I(scale(freq)^4) + (1|beeColHive), data = sl[sl$trialNum == 1, ])

mm2 <- lmer(log(amp_acc2) ~ I(scale(freq)) + I(scale(freq)^2) + I(scale(freq)^3)  + (1|beeColHive), data = sl[sl$trialNum == 1, ])

summary(mm2)

plot(mm2)

plot(x = sl[sl$trialNum == 1, ]$freq, y = exp(predict(mm2, re.form =NA)))





ggplot(sl[sl$trialNum >= 2, ], aes(x = freq, y = amp_acc2)) + 
  geom_point(position = position_jitter(width = 1), alpha = 0.2, stroke = 0) + 
  theme_classic() + 
  facet_wrap(~trt, ncol = 1) + 
  stat_smooth(aes(color = trt), method = "loess", se = TRUE) + 
  labs( y = expression ("Sonication amplitude "(m~s^{-2})), x = "Sonication Frequency (Hz)") + 
  scale_color_viridis_d(name = "Treatment")
ggsave(filename = file.path(figDir, "FreqVAmp_allTrts.png"), width = 6, heigh = 4, dpi = 500, unit = "in")

centerFreq = scale(sl[sl$trialNum == 1, "freq"])

m1 <- lmer(log(amp_acc)~centerFreq + I(centerFreq^2) + I(centerFreq^3) + IT_imputed + (1|beeCol), data = sl[sl$trialNum == 1, ])
summary(m1)

plot(m1)

# predict -- using mean IT span
ppdf <- data.frame(centerFreq = sort(unique(centerFreq)), IT_imputed = ITmean, beeCol = 99999, acc_amp = 0)
# exponentiate to get back to original scale
ppdf$predAmp = exp(predict(m1, newdata = ppdf, type = "response", re.form = NA))



cf_Unscaled = ppdf$centerFreq * attr(centerFreq, 'scaled:scale') + attr(centerFreq, 'scaled:center')
ggplot(ppdf, aes(x = cf_Unscaled, y = predAmp))+ 
  geom_line() + 
  labs(x = "Sonication Frequency (Hz)", y = expression ("Sonication amplitude "(m~s^{-2})) ) + 
  geom_point(data = sl[sl$trialNum == 1, ], 
             aes(x = freq, y = amp_acc), 
             alpha = 0.2, position = position_jitter(width =2), pch =16, size = .5) 
ggsave(filename = file.path(figDir, "FreqVsAmp_1stTrial_rawData.svg"), width = 4, height = 3)

g22 <- ggplot(ppdf, aes(x = cf_Unscaled, y = predAmp))+ 
  geom_line() + 
  labs(x = "Sonication Frequency (Hz)", y = expression ("Predicted sonication amplitude "(m~s^{-2})) ) 
g22
ggsave(filename = file.path(figDir, "FreqVsAmp_1stTrial.svg"), width = 4, height = 3)
 

ggplot(sl, aes(x = trt2, y = IT_imputed)) + 
  geom_point()

 
```


## analyze time between buzzes and num buzzes between rewards
```{r, eval = FALSE}
# convert time to datetime format

# fresh dataset
sl <- read_csv(file.path(dataDir, '01_CombinedTrials_cleaned.csv'))

sl <- sl %>%
  mutate(beeColHive = interaction(beeCol, hive))


options(digits.secs=6)
sl$dateTime_fmt= as.POSIXct(strptime(x = sl$datetime_str, format = "%Y-%m-%d  %H:%M:%OS" ))

sl %>% head

sl$rewTF
colnames(sl)

# calculate time since beginning of trial
trialStart <- sl %>%
  # remove two trials I messed up
  filter(!(beeCol == "whitepink" & trialNum == 3)) %>%
  filter(!(beeCol == "limepurple" & trialNum == 3)) %>%
  
  dplyr::select(beeColHive, trialNum, dateTime_fmt) %>%
  filter(trialNum <= 10) %>%
  group_by(beeColHive, trialNum) %>%
  slice(1:1) %>%
  rename(trialStart = dateTime_fmt) %>%
  full_join(sl) %>%
  mutate(timeSinceStart = difftime(dateTime_fmt , trialStart, unit = 'sec')) %>%
  dplyr::select(beeColHive, trialNum, timeSinceStart, rewTF, dateTime_fmt, trt) %>%
  filter(rewTF == TRUE) %>%
  mutate(timeSinceReward = timeSinceStart - lag(timeSinceStart)) %>%
  arrange((dateTime_fmt)) %>%
  group_by(beeColHive) %>% mutate(index = row_number()) %>%
  filter(!is.na(timeSinceReward)) %>%
  #filter(timeSinceReward < 100000) %>%
  filter(beeColHive %in% .$beeColHive[.$trialNum > 1]) 

# note, use bb from above  
# bb <- trialStart %>%
#   dplyr::select(beeColHive, trt, trialNum) %>%
#   dplyr::filter(trialNum == 2 | trialNum == 3) %>%
#   group_by(beeColHive) %>% 
#   slice(1:1) %>%
#   dplyr::arrange(trt)
# 
# bb

trialStart <- trialStart %>%
  ungroup() %>%
  mutate(beeColHive = factor(beeColHive, levels = bb$beeColHive), 
       t5 = plyr::mapvalues(.$trt, from = c("full", "high", "low"), 
                        to = c("Full range\n(220 - 450 Hz)", 
                               "High range\n(340 - 390 Hz)", "Low range\n(220 - 330 Hz)"))) %>%
  filter(trialNum <= 10)

s44 <- trialStart %>%
 # filter(trialNum == 1) %>%
  group_by(beeColHive, trialNum, t5) %>%
  dplyr::summarise(meanInitialTime = mean((as.numeric(timeSinceReward))))

s44

ggplot(trialStart, aes(x = trialNum, y = as.numeric(timeSinceReward))) + 
  geom_point(alpha = 0.2, aes(color = t5, shape = t5)) + 
  facet_wrap(~beeColHive, ncol = 8) + 
  scale_color_viridis_d(name = "",
                        option = "magma", begin = 0.3,
                        end = 0.80, 
                        guide = guide_legend(override.aes = list(alpha = 1, size = 4))) + 
  scale_shape_manual(name = "", values = c(16,17,15)) + 
  #scale_y_log10() + 
  labs(x = "Trial Number", y = "Time between rewards (s)") + 
  theme_classic() + 
  theme(strip.background = element_blank(), 
        strip.text = element_blank(), 
        panel.border = element_rect(colour = "grey40", 
                                    fill=NA, size=0.5), 
        legend.position = 'top') + 
  # stat_smooth(method = 'loess', se = FALSE, aes(color = t5)) + 
  geom_hline(data = s44[s44$trialNum == 1,], aes(yintercept = as.numeric(meanInitialTime))) +
  
  geom_line(data = s44, aes(y = as.numeric(meanInitialTime), x = trialNum),lwd = 0.8, show.legend = FALSE) +
  geom_line(data = s44, aes(y = as.numeric(meanInitialTime), x = trialNum, color = t5), lwd = 0.8, show.legend = FALSE) +
  geom_point(data = s44, aes(y = as.numeric(meanInitialTime), x = trialNum), pch = 18) +
  scale_x_continuous(breaks = seq(2, 10, 2)) + 
  ylim(c(-1, 100))

ggsave(filename = file.path(figDir,"timeBWRewards.png"),
       dpi = 500,  width = 6.5*1.5, height = 4*1.5, units = "in")




timeSinceStart = list()
timeDiff = list()
timeSinceReward = list()
IDS = character()
prevRewardTime = NA
buzzesSinceReward = list()

# calculate num of buzzes since last reward
for(ii in 1:nrow(sl)){
  
  tmp = sl[ii, c("BeeNumCol", "dateTime_fmt", "rewTF", "index")]
  
  if(!(tmp$BeeNumCol %in% IDS)){
    timeSinceStart[ii] = difftime(tmp$dateTime_fmt, tmp$dateTime_fmt, units = "min")
    timeDiff[ii] = difftime(tmp$dateTime_fmt, tmp$dateTime_fmt, units = "min")
    timeSinceReward[ii] = difftime(tmp$dateTime_fmt, tmp$dateTime_fmt, units = "min")
    buzzesSinceReward[ii] = NA
    if(as.character(tmp$rewTF) == " T"){
      prevRewardTime = tmp$dateTime_fmt
      prevRewardBuzzNum = tmp$index
    }
    else{
       prevRewardTime = NA
       prevRewardBuzzNum = NA
    }
    startTime = tmp$dateTime_fmt
    IDS = append(IDS, as.character(tmp$BeeNumCol))
  }
  else{
    timeSinceStart[ii] = difftime(tmp$dateTime_fmt, startTime, units = "min")
    timeDiff[ii] = difftime(tmp$dateTime_fmt, prevTime, units = "min")
    
    timeSinceReward[ii] = difftime(tmp$dateTime_fmt, prevRewardTime, units = "min")
    buzzesSinceReward[ii] = tmp$index - prevRewardBuzzNum
    if(tmp$rewTF == " T"){
      prevRewardTime = tmp$dateTime_fmt
      prevRewardBuzzNum = tmp$index
    }
  }
  prevTime = tmp$dateTime_fmt

}


sl$timeSinceStart = unlist(timeSinceStart)
sl$timeSinceLastBuzz = unlist(timeDiff)
sl$timeSinceReward = unlist(timeSinceReward)
sl$buzzesSinceReward = unlist(buzzesSinceReward)

#plot(sl$index)
sl %>% head

plot(sl$timeSinceStart[1:500])
plot(sl$timeSinceLastBuzz[1:1000])

plot(na.omit(sl$buzzesSinceReward[1:5000]), xlim = c(0, 5000))

ggplot(data = sl[1:10000, ], mapping = aes(x = index, y = timeSinceReward, color= trt)) + 
# geom_boxplot() + 
   geom_point() + 
  facet_wrap(~trt) + 
  scale_y_log10() + 
  theme(legend.position = "none") + 
  geom_smooth(color = 'grey40') + 
  scale_color_viridis_d(option = "magma", end = 0.9)

ggplot(data = sl[1:10000, ], mapping = aes(x = index, y = timeSinceReward, color= trt)) + 
# geom_boxplot() + 
   geom_point() + 
  facet_wrap(~trt) + 
  scale_y_log10() + 
  theme(legend.position = "none") + 
  geom_smooth(color = 'grey40') + 
  scale_color_viridis_d(option = "magma", end = 0.9)



# plot time vs. reward 

ggplot(data = sl[1000:2000, ], mapping = aes(x = timeSinceStart, y = timeSinceReward, color= trt)) + 
# geom_boxplot() + 
   geom_point(alpha = 0.5) + 
  geom_line() + 
  facet_wrap(~BeeNumCol, scales = 'free') + 
  ylim(-0.1, 1.1) + 
  #geom_smooth() + 
  #theme(legend.position = "none") + 
  scale_color_viridis_d(option = "magma", end = 0.9, begin = 0.2,direction = -1)

# plot buzzes b/w rewards
ggplot(data = sl[grepl(pattern = "t", ignore.case = TRUE, x = sl$rewTF) & !(sl$trt %in% c("full", "full_2")), ][1:5000,], mapping = aes(x = index, y = buzzesSinceReward, color= trt)) + 
# geom_boxplot() + 
   geom_point(alpha = 0.5) + 
  geom_line() + 
  facet_wrap(~BeeNumCol, scales = 'free_x') + 
  #ylim(-0.1, 1.1) + 
  #geom_smooth() + 
  #theme(legend.position = "none") + 
  scale_color_viridis_d(option = "magma", end = 0.9, begin = 0.2,direction = -1)




unique(sl[1000:5000, ]$BeeNumCol)

# View(sl[sl$BeeNumCol == "Beelimered11_16Dec2016_Hive5_low", ])
# View(sl[grepl(pattern = "redpink1", x = as.character(sl$BeeNumCol)), ])
ggplot(data = sl[sl$BeeNumCol == "Beelimered11_16Dec2016_Hive5_low", ], mapping = aes(x = index, y = buzzesSinceReward, color= trt)) + 
# geom_boxplot() + 
   geom_point(alpha = 0.5) + 
  geom_line() + 
  facet_wrap(~BeeNumCol, scales = 'free') + 
  #ylim(-0.1, 1.1) + 
  #geom_smooth() + 
  #theme(legend.position = "none") + 
  scale_color_viridis_d(option = "magma", end = 0.9, begin = 0.2,direction = -1)


ggplot(data = sl[grepl(pattern = "redpink", x = as.character(sl$BeeNumCol)), ], mapping = aes(x = index, y = buzzesSinceReward, color= trt)) + 
# geom_boxplot() + 
   geom_point(alpha = 0.5) + 
  geom_line() + 
  facet_wrap(~BeeNumCol, scales = 'free') + 
  #ylim(-0.1, 1.1) + 
  #geom_smooth() + 
  #theme(legend.position = "none") + 
  scale_color_viridis_d(option = "magma", end = 0.9, begin = 0.2,direction = -1)

ggplot(sl[, ], aes(x = index, y = grepl("t", x = rewTF, ignore.case = TRUE)*1)) +
   geom_point() + 
  geom_smooth() + 
facet_wrap(~trt, scales = 'free')

binomial_smooth <- function(...){
  geom_smooth(method = "glm", method.args = list(family = "binomial"), ...)
}


ggplot(sl[, ], aes(x = timeSinceStart, y = grepl("t", x = rewTF, ignore.case = TRUE)*1)) +
   geom_point() + 
  binomial_smooth() +  
facet_wrap(~trt, scales = 'free')

ggplot(sl[sl$trt2 %in% c("low", "high"), ], aes(x = index, y = grepl("t", x = rewTF, ignore.case = TRUE)*1)) +
   geom_point() + 
  binomial_smooth(aes(color = as.factor(trialNum)), se = FALSE) +  
facet_wrap(~interaction(beeCol , hive, trt), scales = 'free') + 
  scale_color_viridis_d(end = 0.9, option = "magma", direction = -1)

# refref: visualize using overall buzz number (not reset for each trial), but still
# color by trial

IDS = character()
sl <- sl[order(sl$dateTime_fmt), ]
ID1 = interaction(sl$beeCol, sl$hive, sl$trt2)
buzzctr = 0
overallBuzz = numeric(length = nrow(sl))
for(ii in 1:nrow(sl)){
    tmp = ID1[ii]
    if(tmp %in% IDS){
      buzzctr =  max(overallBuzz[ID1 == tmp]) + 1
    }
    else{
      buzzctr = 0
      IDS = append(IDS, as.character(tmp))
    }
    overallBuzz[ii] = buzzctr
    print(ii)
}
sl$overallBuzz = overallBuzz
    
ggplot(sl[sl$trt2 != "full", ], aes(x = overallBuzz, 
                   y = grepl("t", x = rewTF, ignore.case = TRUE)*1, 
                   color = interaction(beeCol, hive, trt2, trialNum))) +
   geom_point() + 
  geom_smooth(se = FALSE) +  
  theme(legend.position = "none") + 
facet_wrap(~interaction(beeCol, hive, trt2), scales = 'free')




ggplot(sl[sl$trt2 != "full", ], aes(x = overallBuzz, 
                   y = freq, 
                   color = grepl("t", x = rewTF, ignore.case = TRUE))) +
   geom_point() + 
  stat_smooth(method = "loess", se = FALSE, color = "grey40", span = 0.9, lwd= 5) +  
  #theme(legend.position = "none") + 
facet_wrap(~interaction(beeCol, hive, trt2), scales = 'free') + 
  scale_color_viridis_d(name = "Reward")


ggplot(sl[sl$trt2 != "full", ], aes(x = overallBuzz, 
                   y = freq)) +
  geom_ribbon(aes(ymin=lowFrq,ymax=highFrq), fill="grey10", alpha= 0.9, color = NA) +
   geom_hex(binwidth = c(150, 10)) + 
  
  #theme(legend.position = "none") + 
facet_wrap(interaction(beeCol, hive, trt2)~., ncol = 6) + 
  scale_fill_viridis_c(name = "Num buzzes") + 
  geom_hline(aes(yintercept = lowFrq), color = 'grey40', size = 1, lty = 2) + 
  geom_hline(aes(yintercept = highFrq), color = 'grey40', size = 1, lty = 2) 
  


# refref calculate time differences b/w rewards
ggplot(sl[grepl(pattern = "t", x = as.character(sl$rewTF), ignore.case = TRUE) & sl$trt != "full", ], aes(x = as.factor(trialNum), y = timeSinceReward)) + 
         geom_point(aes(color= as.factor(trialNum))) + 
  facet_wrap(interaction(beeCol, hive, trt2)~., ncol = 6, scales = 'free_x') +
  ylim(c(0,1))


# num buzzes b/w rewards
ggplot(sl[grepl(pattern = "t", x = as.character(sl$rewTF), ignore.case = TRUE) & sl$trt2 != "full", ], aes(x = overallBuzz, y = buzzesSinceReward)) + 
         geom_point() + 
  facet_wrap(interaction(beeCol, hive, trt2)~., ncol = 6)


# num buzzes b/w rewards
ggplot(sl[grepl(pattern = "t", x = as.character(sl$rewTF), ignore.case = TRUE) & sl$trt2 != "full", ], aes(x = interaction(index < 50, as.factor(trialNum)), y = buzzesSinceReward, fill = index < 50)) + 
         geom_boxplot() + 
  
  theme(axis.text.x = element_text(angle = 90)) + 
  facet_wrap(interaction(beeCol, hive, trt2)~., ncol = 6, scales = 'free_x') + 
  scale_color_viridis_d()


#refref: calculate continuous time for each bee
sl$continuousTime = 0
sl$beeID = interaction(sl$beeCol, sl$hive)
jj = "orange.3"
kk = 1
for(jj in unique(sl$beeID)){
  tmp = sl[sl$beeID == jj, ]
  tmp %>% head()
  # sort
  tmp <- tmp[order(tmp$dateTime_fmt), ]
  
  times = numeric()
  trials = numeric()
  kk = 1
  for(kk in 1:nrow(tmp)){
    if(!(tmp$trialNum[kk] %in% trials)){
      trials <<- append(trials, tmp$trialNum[kk])
        if(kk == 1){
        times[kk] = 0
        }
      else{
        times[kk-1] = max(times)
      }
      
    }
    if(kk == 1){
        times[kk] = 0
        }
    else{
      times[kk] =  tmp$timeSinceLastBuzz[kk] + times[kk -1]
    }
  }
  tmp$continuousTime = times
  #plot(times)
  sl <- merge(sl, tmp, all = TRUE)
  
}

sl %>% head()



# proportion of rewarded buzzes over time
ggplot(sl, aes(x = timeSinceStart, y = grepl("t", x = rewTF, ignore.case = TRUE)* 1)) + 
  geom_point() + 
  theme(legend.position = "none") + 
  stat_smooth(method = "loess", aes(color = interaction(beeCol, hive, trt2, trialNum)), se = FALSE) + 
  facet_wrap(interaction(beeCol, hive, trt2)~., ncol = 6, scales = 'free_x') + 
  scale_color_viridis_d() + ylim(c(0, 1))

```


```{r}
sessionInfo()
```

